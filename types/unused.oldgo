
//TODO: remove unused code
// //spanToRangeList converts the spans specified in each command into a list of Type.Range ready for use
// func oldspanToRangeList(cmdList []*Command, cmdType RwKeyWord) (rList []Range, err error) {
// 	var sList []*Span
// 	for _, cmd := range cmdList {
// 		if cmd.token != cmdType {
// 			continue
// 		}
// 		tmpList, err := cmd.cellSpan.ExpandSpan()
// 		if err != nil {
// 			return nil, err
// 		}
// 		sList = append(sList, tmpList...)
// 	}
// 	sList = DeduplicateSpanList(sList)
// 	for _, s := range sList {
// 		rList = append(rList, SpanToRange(s))
// 	}
// 	sort.Slice(rList, func(i, j int) bool {
// 		return rList[i].less(rList[j])
// 	})
// 	return rList, nil
// }

// func searchMRListByRange(mrlist []Range, mr Range) (index int, found bool) {
// 	index = sort.Search(len(mrlist), func(i int) bool { //see https://golang.org/pkg/sort/#Search
// 		return !mrlist[i].less(mr)
// 	})
// 	if index < len(mrlist) && mrlist[index] == mr {
// 		return index, true
// 	}
// 	return -1, false
// }

// func searchMRListByCoordinate(mrlist []Range, coord Coordinates) (index int) {
// 	if len(mrlist) == 0 {
// 		return -1
// 	}
// 	index = sort.Search(len(mrlist), func(i int) bool { //see https://golang.org/pkg/sort/#Search
// 		return mrlist[i].TopLeft.Row >= coord.Row ||
// 			(mrlist[i].TopLeft.Row == coord.Row && mrlist[i].TopLeft.Col >= coord.Col)
// 	})
// 	if index < len(mrlist) && mrlist[index].TopLeft == coord {
// 		return index
// 	}
// 	return -1
// }


//TODO: remove OLD CODE
//deduplicateSpanList returns deduplicated (unique r1,r2,c1,c2) span List
// func deduplicateSpanList(sList []*Span) []*Span {
// 	set := make(map[string]*Span, len(sList))
// 	i := 0
// 	for _, s := range sList {
// 		if _, exists := set[s.String()]; exists {
// 			continue
// 		}
// 		set[s.String()] = s
// 		sList[i] = s
// 		i++
// 	}
// 	return sList[:i]
// }

// //ExpandSpan convert by and comma list spans into simple (topleft, bottomright only) spans
// func (s *Span) ExpandSpan() (sList []*Span, err error) {
// 	var rPoints, cPoints []int
// 	//if skipped span (eg 1:2:10), generate Lists of all row and col points included
// 	if s.rby != RwMissing {
// 		if rPoints = genAllPossibleRangePoints(s.r1, s.r2, s.rby); rPoints == nil {
// 			return nil, fmt.Errorf("invalid span %s", s)
// 		}
// 	}
// 	if s.cby != RwMissing {
// 		if cPoints = genAllPossibleRangePoints(s.c1, s.c2, s.cby); cPoints == nil {
// 			return nil, fmt.Errorf("invalid span %s", s)
// 		}
// 	}
// 	//if comma-separated, add to above Lists (which could be empty)
// 	rPoints = append(rPoints, s.rcl...)
// 	cPoints = append(cPoints, s.ccl...)

// 	switch {
// 	//scenario 1: simple (no steps or comma list) span, eg style row 1:3 col 1:2, return it
// 	case len(rPoints) == 0 && len(cPoints) == 0:
// 		sList = append(sList, s)
// 	//scenario 2: both columns and rows are complex, create a span for each affected row and col combination
// 	//eg style row 1:2:6 col 1:2:6 --> row 1:1 col 1:1; row 3:3 col 1:1; row 5:5 col 1:1, repeat for col 3:3 & 5:5
// 	case len(rPoints) != 0 && len(cPoints) != 0:
// 		for _, r := range rPoints {
// 			for _, c := range cPoints {
// 				sList = append(sList, MakeSpan(r, r, c, c))
// 			}
// 		}
// 	//scenario 3: rows complex but cols simple, create a span for each affected row
// 	//eg style row 1:2:6 col 1:1 --> row 1:1 col 1:1; row 3:3 col 1:1; row 5:5 col 1:1
// 	case rPoints != nil:
// 		for _, r := range rPoints {
// 			sList = append(sList, MakeSpan(r, r, s.c1, s.c2))
// 		}
// 	//scenario 4: rows simple but cols complex, create a span for each affected col
// 	//eg row 1:1 col 1:2:6 --> row 1:1 col 1:1; row 1:1 col 3:3; row 1:1 col 5:5
// 	case cPoints != nil:
// 		for _, c := range cPoints {
// 			sList = append(sList, MakeSpan(s.r1, s.r2, c, c))
// 		}
// 	}
// 	return deduplicateSpanList(sList), nil
// }
