
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/drgo/rosewood/cmd_parser.go (89.8%)</option>
				
				<option value="file1">github.com/drgo/rosewood/command.go (69.4%)</option>
				
				<option value="file2">github.com/drgo/rosewood/errors.go (35.3%)</option>
				
				<option value="file3">github.com/drgo/rosewood/html_render.go (96.0%)</option>
				
				<option value="file4">github.com/drgo/rosewood/interpreter.go (52.1%)</option>
				
				<option value="file5">github.com/drgo/rosewood/run_set.go (0.0%)</option>
				
				<option value="file6">github.com/drgo/rosewood/settings.go (100.0%)</option>
				
				<option value="file7">github.com/drgo/rosewood/table.go (50.0%)</option>
				
				<option value="file8">github.com/drgo/rosewood/table_data.go (60.4%)</option>
				
				<option value="file9">github.com/drgo/rosewood/utils.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package rosewood

import (
        "fmt"
        "io"
        "log"
        "strconv"
        "strings"
        "text/scanner"
)

// keyword lookup
type rwKeyWord int

const (
        kwInvalid rwKeyWord = iota
        kwMerge
        kwStyle
        kwSet
        kwUse
)

var keywords = map[string]rwKeyWord{
        "merge": kwMerge,
        "style": kwStyle,
        "set":   kwSet,
        "use":   kwUse,
}

func lookupKeyword(name string) (kw rwKeyWord, isKeyWord bool) <span class="cov8" title="1">{
        kw, isKeyWord = keywords[name]
        return
}</span>

// RunMode describes Parser's running mode
type RunMode int

const (
        Interactive RunMode = iota
        ScriptRun
)

// CommandParser specialized parser for format commands
type CommandParser struct {
        errors       *ErrorManager
        lexer        *scanner.Scanner
        settings     *Settings
        debug        bool
        runMode      RunMode
        currentToken rune
        tables       []*tableData //list of all loaded tables
}

//NewCommandParser initializes and returns a CommandParser
func NewCommandParser(settings *Settings) *CommandParser <span class="cov8" title="1">{
        p := CommandParser{errors: NewErrorManager()}
        //if no custom settings use default ones
        if settings == nil </span><span class="cov0" title="0">{
                panic("nil settings passed to command parser")</span>
        }
        <span class="cov8" title="1">p.settings = settings
        p.runMode = settings.RunMode
        return &amp;p</span>
}

//defaultSettings: returns default settings in case no settings were set.
func (p *CommandParser) defaultSettings() error <span class="cov0" title="0">{
        p.settings = NewSettings()
        p.settings.RangeOperator = ':'
        if p.settings.Debug </span><span class="cov0" title="0">{
                log.Printf("default settings loaded")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

//Errors returns a \n separated list of errors
func (p *CommandParser) Errors(index int) string <span class="cov0" title="0">{
        if index &lt; 0 </span><span class="cov0" title="0">{
                return p.errors.String()
        }</span>
        <span class="cov0" title="0">return p.errors.Errors[index].Error()</span>
}

//nextToken: advances the lexer and updates currentToken of CommandParser. Do not
//confuse with Go's scanner.Scanner.Next()
func (p *CommandParser) nextToken() <span class="cov8" title="1">{
        p.currentToken = p.lexer.Scan()
        if p.settings.Debug </span><span class="cov8" title="1">{
                log.Printf("in nextToken: %s, current token= %q\n", p.lexer.Pos(), p.lexer.TokenText())
        }</span>
}

//wrongToken adds an error into the parser's error list
func (p *CommandParser) wrongToken(wantedText string) <span class="cov8" title="1">{
        if strings.HasPrefix(wantedText, "*") </span><span class="cov8" title="1">{
                wantedText = wantedText[1:] //do not print the *
        }</span>
        <span class="cov8" title="1">p.errors.Add(NewError(ErrSyntaxError, p.lexer.Pos(), fmt.Sprintf("expected %s, found %s (%s)",
                wantedText, scanner.TokenString(p.currentToken), p.lexer.TokenText())))</span>
}

//wrongToken adds an error into the parser's error list
func (p *CommandParser) addSyntaxError(msg string) <span class="cov8" title="1">{
        p.errors.Add(NewError(ErrSyntaxError, p.lexer.Pos(), msg))
}</span>

//accept
// if wantedText =="*", wantedText is not validated
func (p *CommandParser) accept(wantedTok rune, wantedText string) <span class="cov8" title="1">{
        if p.currentToken != wantedTok </span><span class="cov8" title="1">{
                p.wrongToken(wantedText)
        }</span>
        <span class="cov8" title="1">if strings.HasPrefix(wantedText, "*") </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if wantedText != strings.ToLower(p.lexer.TokenText()) </span><span class="cov8" title="1">{
                p.addSyntaxError(fmt.Sprintf("expected %s, found %s", wantedText, p.lexer.TokenText()))
        }</span>
}

//acceptCommandName: reads and validates a command name
func (p *CommandParser) acceptCommandName() (string, rwKeyWord) <span class="cov8" title="1">{
        cmdName := strings.ToLower(p.lexer.TokenText())
        if p.currentToken != scanner.Ident </span><span class="cov8" title="1">{
                p.wrongToken("command")
                return cmdName, kwInvalid
        }</span>
        <span class="cov8" title="1">cmd, found := lookupKeyword(cmdName)
        if !found </span><span class="cov8" title="1">{
                p.addSyntaxError(fmt.Sprintf("unknown command %s", cmdName))
                return cmdName, kwInvalid
        }</span>
        <span class="cov8" title="1">return cmdName, cmd</span>
}

//acceptCoordinate: reads and validates a row/cell coordinate
func (p *CommandParser) acceptCoordinate() RwInt <span class="cov8" title="1">{
        if p.currentToken != scanner.Int </span><span class="cov8" title="1">{
                p.wrongToken("integer")
                return MissingRwInt
        }</span>
        <span class="cov8" title="1">coordinate, _ := strconv.Atoi(p.lexer.TokenText()) //no error check as we know it must be an int
        if coordinate &lt; 1 </span><span class="cov8" title="1">{
                p.addSyntaxError(fmt.Sprintf("wanted row/col number &gt; 0; found %s", p.lexer.TokenText()))
                return MissingRwInt
        }</span>
        <span class="cov8" title="1">return RwInt(coordinate)</span>
}

//acceptArgNameAndValue: reads an argument name and its value
func (p *CommandParser) acceptArg(lexeme rune) string <span class="cov8" title="1">{
        p.accept(lexeme, "*any identifier")
        return strings.ToLower(p.lexer.TokenText())
}</span>

func (p *CommandParser) init(r io.Reader) error <span class="cov8" title="1">{
        if r == nil </span><span class="cov0" title="0">{
                panic("ParseCommands called with nil io.Reader")</span>
        }
        <span class="cov8" title="1">p.errors.Reset()
        //initialize lexer and its settings
        p.lexer = new(scanner.Scanner).Init(r)
        p.lexer.Whitespace = 1&lt;&lt;'\t' | 1&lt;&lt;'\r' | 1&lt;&lt;' ' //ignore spaces, tabs and CRs

        return nil</span>
}

//ParseCommands parses input stream and return an array of commands
func (p *CommandParser) ParseCommands(r io.Reader) ([]*Command, error) <span class="cov8" title="1">{
        if err := p.init(r); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">var cmd *Command
        var cmdList []*Command

        p.nextToken()
        if p.currentToken == scanner.EOF </span><span class="cov8" title="1">{
                return nil, NewError(ErrEmpty, scanner.Position{Line: -1, Column: -1}, "nothing to parse")
        }</span>
        <span class="cov8" title="1">cmdList = make([]*Command, 0, sectionCapacity)

        for ; p.currentToken != scanner.EOF; p.nextToken() </span><span class="cov8" title="1">{
                if p.currentToken == '\n' </span><span class="cov8" title="1">{ //handle lines with no text, just linefeeds
                        p.accept('\n', "*end of line") //advance beyond it and loop back
                        continue</span>
                }
                <span class="cov8" title="1">cmdName, cmdToken := p.acceptCommandName()
                cmd = NewCommand(cmdName, cmdToken, p.lexer.Pos())
                switch cmdName </span>{
                case "set":<span class="cov8" title="1">
                        p.parseSetCommand(cmd)</span>
                default:<span class="cov8" title="1">
                        p.parseTableFormatCommand(cmd)</span> //all other commands will be parsed as a formatting command
                }
                <span class="cov8" title="1">if p.currentToken == '\n' </span><span class="cov8" title="1">{
                        p.accept('\n', "*end of line")
                }</span>
                <span class="cov8" title="1">err := cmd.Validate()
                if err != nil </span><span class="cov8" title="1">{
                        p.addSyntaxError(err.Error())
                }</span>
                <span class="cov8" title="1">cmdList = append(cmdList, cmd)</span>
        }

        <span class="cov8" title="1">if len(cmdList) == 0 </span><span class="cov8" title="1">{
                return nil, NewError(ErrEmpty, scanner.Position{Line: -1, Column: -1}, "found no valid commands")
        }</span>
        <span class="cov8" title="1">if p.errors.Count() &gt; 0 </span><span class="cov8" title="1">{
                return nil, NewError(ErrGeneric, scanner.Position{Line: -1, Column: -1}, "syntax errors")
        }</span>
        <span class="cov8" title="1">return cmdList, nil</span>
}

//parseTableFormatCommand: parses a command like command row col args
func (p *CommandParser) parseTableFormatCommand(cmd *Command) error <span class="cov8" title="1">{
        p.nextToken()
        p.accept(scanner.Ident, "row") //read row info
        p.nextToken()
        cmd.cellRange.TopLeft.Row = p.acceptCoordinate()
        p.nextToken()
        //        fmt.Printf("in parseTable %q: %d\n", string(p.rangeOperator), p.rangeOperator)
        colExists := false
        switch p.currentToken </span>{
        case '\n', scanner.EOF:<span class="cov8" title="1">
                // fmt.Printf("inside end of line or EOF: mandatory: %t, colexists: %t\n", p.settings.MandatoryCol, colExists)
                if p.settings.MandatoryCol &amp;&amp; !colExists </span><span class="cov0" title="0">{
                        p.addSyntaxError("col is missing")
                }</span>
                <span class="cov8" title="1">return nil</span>
        case p.settings.RangeOperator:<span class="cov8" title="1">
                p.nextToken()
                cmd.cellRange.BottomRight.Row = p.acceptCoordinate()
                p.nextToken()
                fallthrough</span>
        case scanner.Ident:<span class="cov8" title="1"> //either "col" or an argument list
                switch strings.ToLower(p.lexer.TokenText()) </span>{
                case "col":<span class="cov8" title="1"> //read col info
                        p.accept(scanner.Ident, "col")
                        p.nextToken()
                        cmd.cellRange.TopLeft.Col = p.acceptCoordinate()
                        colExists = true
                        p.nextToken()
                        //fmt.Println(p.rangeOperator, "--&gt;", p.currentToken)
                        if p.currentToken == p.settings.RangeOperator </span><span class="cov8" title="1">{
                                p.nextToken()
                                cmd.cellRange.BottomRight.Col = p.acceptCoordinate()
                                p.nextToken()
                        }</span>
                        <span class="cov8" title="1">fallthrough</span>
                default:<span class="cov8" title="1"> //read args
                        for ; p.currentToken != '\n' &amp;&amp; p.currentToken != scanner.EOF; p.nextToken() </span><span class="cov8" title="1">{
                                arg := p.acceptArg(scanner.Ident)
                                cmd.args = append(cmd.args, arg)
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

//parseSetCommand: parses a command like "set settingname settingvalue"
func (p *CommandParser) parseSetCommand(cmd *Command) error <span class="cov8" title="1">{
        p.nextToken()
        settingName := p.acceptArg(scanner.Ident)
        p.nextToken()
        settingValue := p.acceptArg(scanner.String)
        p.nextToken()
        cmd.args = append(cmd.args, settingName, settingValue)
        return nil
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package rosewood

import (
        "fmt"
        "strconv"
        "strings"
        "text/scanner"
)

//RwInt used for all table cell coordinates
type RwInt uint

//Missing, min and max values for RwInt
const (
        MissingRwInt = ^RwInt(0)        //flip bits of zero to all 1s to get max uint for use as a sentinel for missing values
        MaxRwInt     = MissingRwInt - 1 //use this as the MaxUnit
        MinRwInt     = 0
)

type Args []string

func (args Args) String() string <span class="cov8" title="1">{
        if len(args) == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">return strings.Join(args, ",")</span>
}

//Arg returns the index-th argument as unquoted string
func (args Args) Arg(index int) string <span class="cov0" title="0">{
        if index &lt; 0 || index &gt;= len(args) </span><span class="cov0" title="0">{
                panic("rwArgs.UnquoteString called with invalid index")</span>
        }
        <span class="cov0" title="0">if s, err := strconv.Unquote(args[index]); err == nil </span><span class="cov0" title="0">{
                return s
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type Coordinate struct {
        Row, Col RwInt
}

func formattedRwInt(value RwInt) []byte <span class="cov8" title="1">{ //return byte array for ease of concatenating with other text
        buf := []byte{}
        if value == MissingRwInt </span><span class="cov8" title="1">{
                buf = append(buf, 'N', 'A') //use NA for missing
        }</span><span class="cov8" title="1"> else {
                buf = strconv.AppendUint(buf, uint64(value), 10)
        }</span>
        <span class="cov8" title="1">return buf</span>
}

func (co Coordinate) String() string <span class="cov0" title="0">{
        buf := formattedRwInt(co.Row)
        buf = append(buf, ':')
        buf = formattedRwInt(co.Col)
        return string(buf)
}</span>

type Range struct {
        TopLeft     Coordinate
        BottomRight Coordinate
}

//newRange return an empty a range
func newRange() Range <span class="cov8" title="1">{
        return Range{Coordinate{MinRwInt, MinRwInt}, Coordinate{MissingRwInt, MissingRwInt}} //assume topleft =(0,0)
}</span>

func (r Range) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("row %s col %s", r.TopLeft.String(), r.BottomRight.String())

}</span>
func (r Range) testString() string <span class="cov8" title="1">{
        return fmt.Sprintf("row %s:%s col %s:%s", formattedRwInt(r.TopLeft.Row), formattedRwInt(r.BottomRight.Row),
                formattedRwInt(r.TopLeft.Col), formattedRwInt(r.BottomRight.Col))
}</span>

func (r Range) Validate() error <span class="cov8" title="1">{
        if r.BottomRight.Row &lt; r.TopLeft.Row /* &amp;&amp; r.BottomRight.Row != -1 */ </span><span class="cov8" title="1">{ //TopLeft.Row cannot be optional (-1)
                return fmt.Errorf("top row number (%d) must be smaller than bottom row number (%d)", r.TopLeft.Row, r.BottomRight.Row)
        }</span>
        // if r.BottomRight.Col == -1 &amp;&amp; r.TopLeft.Col == -1 { //if both missing, nothing to validate
        //         return nil
        // }
        <span class="cov8" title="1">if r.BottomRight.Col &lt; r.TopLeft.Col /* &amp;&amp; r.BottomRight.Col != -1 */ </span><span class="cov8" title="1">{ //one or both of them are not missing
                return fmt.Errorf("left column number (%d) must be smaller than right column number (%d)",
                        r.TopLeft.Col, r.BottomRight.Col)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

//Command is the AST for a rw command.
type Command struct {
        token     rwKeyWord
        name      string
        cellRange Range
        args      Args
        pos       scanner.Position
        //        execOrder int
}

//NewCommand return an empty RwCommand
func NewCommand(name string, token rwKeyWord, pos scanner.Position) *Command <span class="cov8" title="1">{
        return &amp;Command{token: token, name: name, pos: pos, cellRange: newRange()}
}</span>

//formats command for printing
func (c *Command) String() string <span class="cov8" title="1">{
        switch c.token </span>{
        case kwSet:<span class="cov8" title="1">
                return fmt.Sprintf("%s %s", c.name, c.args)</span>
        default:<span class="cov8" title="1">
                return fmt.Sprintf("%s %s %s", c.name, c.cellRange.testString(), c.args)</span>
        }
}

//Validate checks command for errors
func (c *Command) Validate() error <span class="cov8" title="1">{
        var err error
        switch c.token </span>{
        case kwSet:<span class="cov8" title="1">
                if len(c.args) != 2 </span><span class="cov0" title="0">{
                        return fmt.Errorf("expected 2 arguments, found %d arguments", len(c.args))
                }</span>
        case kwMerge:<span class="cov8" title="1">
                return c.cellRange.Validate()</span>
        case kwStyle:<span class="cov8" title="1">
                return err</span>
        default:</span><span class="cov8" title="1">
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package rosewood

import (
        "bytes"
        "fmt"
        "text/scanner"
)

type rwError int

const (
        ErrGeneric rwError = iota
        ErrSyntaxError
        ErrEmpty
)

// A EmError is a generic error returned for parsing errors.
// The first line is 1.  The first column is 0.
type EmError struct {
        Type rwError
        scanner.Position
        Message string
}

func (e EmError) Error() string <span class="cov0" title="0">{
        var msg string
        switch e.Type </span>{
        case ErrSyntaxError:<span class="cov0" title="0">
                msg = fmt.Sprintf("%sline %d:%d: %s", "syntax error:", e.Line, e.Column, e.Message)</span>
        case ErrEmpty:<span class="cov0" title="0">
                msg = fmt.Sprintf("%sline %d:%d: %s", "", e.Line, e.Column, "nothing to parse")</span>
        default:<span class="cov0" title="0">
                msg = fmt.Sprintf("%sline %d:%d: %s", "", e.Line, e.Column, e.Message)</span>
        }
        <span class="cov0" title="0">return msg</span>
}

func NewError(etype rwError, pos scanner.Position, msg string) *EmError <span class="cov8" title="1">{
        return &amp;EmError{etype, pos, msg}
}</span>

//ErrorManager stores and prints errors
type ErrorManager struct {
        Errors []error
}

func NewErrorManager() *ErrorManager <span class="cov8" title="1">{
        return &amp;ErrorManager{Errors: make([]error, 0, 10)} //start with an initial capacity of 10 errors
}</span>

func (em *ErrorManager) Add(e error) <span class="cov8" title="1">{
        em.Errors = append(em.Errors, e)
}</span>

func (em *ErrorManager) Count() int <span class="cov8" title="1">{
        return len(em.Errors)
}</span>

func (em *ErrorManager) Reset() <span class="cov8" title="1">{
        em.Errors = nil //for clarity
        em.Errors = make([]error, 0, 10)
}</span>

func (em *ErrorManager) String() string <span class="cov0" title="0">{
        var b bytes.Buffer
        for i := 0; i &lt; len(em.Errors); i++ </span><span class="cov0" title="0">{
                b.WriteString(em.Errors[i].Error())
                b.WriteString("\n")
        }</span>
        <span class="cov0" title="0">return b.String()</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package rosewood

import (
        "bytes"
        "io"
        "strconv"
)

const (
        htmlHeader = `
&lt;!DOCTYPE html&gt;
&lt;head&gt;
&lt;meta charset="utf-8"&gt;
&lt;link rel="stylesheet" href="offset-v0_1_0.css"&gt;
&lt;/head&gt;
&lt;body&gt;
`
        htmlFooter = `
&lt;/body&gt;
&lt;/html&gt;
`
        htmlOpenTable = `&lt;table class=""&gt;
        `
        htmlCloseTable = `&lt;/table&gt;
        `
        htmlOpenRow  = `&lt;tr&gt;`
        htmlCloseRow = `&lt;/tr&gt;
        `
)

type HtmlRenderer struct {
        w        io.Writer
        settings *Settings
        tables   []*table
}

func NewHtmlRenderer() *HtmlRenderer <span class="cov8" title="1">{
        return &amp;HtmlRenderer{}
}</span>

func (hr *HtmlRenderer) SetWriter(w io.Writer) error <span class="cov8" title="1">{
        hr.w = w
        return nil
}</span>

func (hr *HtmlRenderer) SetSettings(settings *Settings) error <span class="cov8" title="1">{
        hr.settings = settings
        return nil
}</span>

func (hr *HtmlRenderer) SetTables(tables []*table) error <span class="cov8" title="1">{
        hr.tables = tables
        return nil
}</span>

func (hr *HtmlRenderer) StartFile() error <span class="cov8" title="1">{
        io.WriteString(hr.w, htmlHeader)
        return nil
}</span>

func (hr *HtmlRenderer) EndFile() error <span class="cov8" title="1">{
        io.WriteString(hr.w, htmlFooter)
        return nil
}</span>

func (hr *HtmlRenderer) StartTable(t *table) error <span class="cov8" title="1">{
        if t.caption != nil &amp;&amp; t.caption.LineCount() &gt; 0 </span><span class="cov0" title="0">{
                io.WriteString(hr.w, t.caption.String()) //strings.Join(t.caption.lines, "")
        }</span>
        <span class="cov8" title="1">io.WriteString(hr.w, htmlOpenTable)
        return nil</span>
}

func (hr *HtmlRenderer) EndTable(t *table) error <span class="cov8" title="1">{
        io.WriteString(hr.w, htmlCloseTable)
        if t.footnotes != nil &amp;&amp; t.footnotes.LineCount() &gt; 0 </span><span class="cov0" title="0">{
                io.WriteString(hr.w, t.footnotes.String()) //strings.Join(t.caption.lines, "")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (hr *HtmlRenderer) StartRow(r *Row) error <span class="cov8" title="1">{
        io.WriteString(hr.w, htmlOpenRow)
        return nil
}</span>

func (hr *HtmlRenderer) EndRow(r *Row) error <span class="cov8" title="1">{
        io.WriteString(hr.w, htmlCloseRow)
        return nil
}</span>

func (hr *HtmlRenderer) OutputCell(c *Cell) error <span class="cov8" title="1">{
        if c.hidden </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">var b bytes.Buffer
        b.WriteString("&lt;td")
        if c.rowSpan &gt; 0 </span><span class="cov8" title="1">{
                b.WriteString(` rowspan="` + strconv.Itoa(int(c.rowSpan)) + `"`)
        }</span>
        <span class="cov8" title="1">if c.colSpan &gt; 0 </span><span class="cov8" title="1">{
                b.WriteString(` colspan="` + strconv.Itoa(int(c.colSpan)) + `"`)
        }</span>
        <span class="cov8" title="1">b.WriteString("&gt;")
        b.WriteString(c.text)
        b.WriteString("&lt;/td&gt;")
        io.WriteString(hr.w, b.String())
        return nil</span>
}

func render(w io.Writer, r *HtmlRenderer, settings *Settings, tables ...*table) error <span class="cov8" title="1">{
        //        fmt.Printf("%#v", *t)
        r.SetWriter(w)
        r.SetSettings(settings)
        r.SetTables(tables)
        r.StartFile()
        for _, t := range tables </span><span class="cov8" title="1">{
                r.StartTable(t)
                for _, row := range t.contents.rows </span><span class="cov8" title="1">{
                        r.StartRow(row)
                        for _, cell := range row.cells </span><span class="cov8" title="1">{
                                r.OutputCell(cell)
                        }</span>
                        <span class="cov8" title="1">r.EndRow(row)</span>
                }
                <span class="cov8" title="1">r.EndTable(t)</span>
        }
        <span class="cov8" title="1">r.EndFile()
        return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package rosewood

import (
        "bufio"
        "bytes"
        "fmt"
        "io"
        "os"
        "strings"
)

//Version of this library
const Version = "0.3.0"

const (
        sectionCapacity  = 100
        sectionsPerTable = 4
        sectionSeparator = "+++"
        columnSeparator  = "|"
)

type sectionDescriptor int

const (
        sectionUnknown sectionDescriptor = iota
        sectionCaption
        sectionBody
        sectionFootNotes
        sectionControl
)

type section struct {
        scriptIdentifer string
        offset          int
        kind            sectionDescriptor
        lines           []string
}

//todo: change section to byte.buffer or []bytes
func newSection(scriptIdentifer string, offset int, kind sectionDescriptor) *section <span class="cov8" title="1">{
        return &amp;section{scriptIdentifer: scriptIdentifer, offset: offset, kind: kind}
}</span>

func (s *section) String() string <span class="cov8" title="1">{
        return strings.Join(s.lines, "\n")
}</span>

func (s *section) LineCount() int <span class="cov8" title="1">{
        return len(s.lines)
}</span>

// var tablePattern = regexp.MustCompile(`\|\S*|\s\|`) //eg "text|", "2131|", "|"

// func (s *section) hasTablePattern() bool {
//         return s.LineCount() != 0 &amp;&amp; tablePattern.MatchString(s.lines[len(s.lines)-1])
// }

type Interpreter struct {
        fileName string
        sections []*section //holds raw lines
        settings *Settings
        tables   []*table
        //        logFile      *os.File
        parser *CommandParser
}

func NewInterpreter(settings *Settings) *Interpreter <span class="cov8" title="1">{
        ri := &amp;Interpreter{}
        //if no custom settings use default ones
        if settings == nil </span><span class="cov8" title="1">{
                ri.settings = DefaultSettings()
        }</span><span class="cov0" title="0"> else {
                ri.settings = settings
        }</span>
        <span class="cov8" title="1">if ri.settings == nil </span><span class="cov0" title="0">{
                panic("Interpreter failed to load settings")</span>
        }
        <span class="cov8" title="1">ri.parser = NewCommandParser(ri.settings)
        return ri</span>
}

func (ri *Interpreter) String() string <span class="cov0" title="0">{
        var b bytes.Buffer
        for i := 0; i &lt; sectionsPerTable; i++ </span><span class="cov0" title="0">{
                b.WriteString(sectionSeparator + "\n")
                b.WriteString(ri.sections[i].String())
                b.WriteString("\n")
        }</span>
        <span class="cov0" title="0">return b.String()</span>
}

func (ri *Interpreter) SectionCount() int <span class="cov8" title="1">{
        return len(ri.sections)
}</span>

func (ri *Interpreter) OK() bool <span class="cov0" title="0">{
        return true
}</span>

func (ri *Interpreter) report(message string, status ReportStatus) <span class="cov0" title="0">{
        if ri.settings.Report != nil </span><span class="cov0" title="0">{
                ri.settings.Report(message, status)
        }</span>
}

func (ri *Interpreter) createTables() error <span class="cov8" title="1">{
        if ri.SectionCount() == 0 || ri.SectionCount()%sectionsPerTable != 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("incorrect number of sections %d", ri.SectionCount())
        }</span>
        <span class="cov8" title="1">var t *table
        var err error
        for i, s := range ri.sections </span><span class="cov8" title="1">{
                ii := i + 1 //i is zero-based, section numbers should be one-based
                s.kind = sectionDescriptor(i%sectionsPerTable + 1)
                switch s.kind </span>{
                case sectionCaption:<span class="cov8" title="1">
                        t = newTable()
                        t.caption = s</span>
                case sectionBody:<span class="cov8" title="1">
                        // if !s.hasTablePattern() {
                        //         return fmt.Errorf("section # %d must be a table content but is not", ii)
                        // }
                        if t.contents, err = ParseTableData(s.String()); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("error parsing table in section # %d: %s ", ii, err)
                        }</span>
                case sectionFootNotes:<span class="cov8" title="1">
                        t.footnotes = s</span>
                case sectionControl:<span class="cov8" title="1">
                        if t.cmdList, err = ri.parser.ParseCommands(strings.NewReader(s.String())); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("error parsing commands in section # %d: %s ", ii, err)
                        }</span>
                        <span class="cov8" title="1">ri.tables = append(ri.tables, t)</span>
                default:<span class="cov0" title="0">
                        panic(fmt.Sprintf("invalid switch case [%v] in Interpreter.CreateTables()", s.kind))</span>
                }
        }
        <span class="cov8" title="1">if len(ri.tables) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("unknown error in Interpreter.CreateTables()")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

//Parse takes an io.Reader containing RoseWood script and an optional script identifier and return an error
func (ri *Interpreter) Parse(r io.Reader, scriptIdentifer string) error <span class="cov8" title="1">{
        err := ri.parse(r, scriptIdentifer)
        if err != nil </span><span class="cov0" title="0">{
                ri.report(err.Error(), Info)
        }</span>
        <span class="cov8" title="1">return err</span>
}

func (ri *Interpreter) parse(r io.Reader, scriptIdentifer string) error <span class="cov8" title="1">{
        // helper functions
        isSectionSeparatorLine := func(line string) bool </span><span class="cov8" title="1">{
                return strings.HasPrefix(strings.TrimSpace(line), sectionSeparator)
        }</span>

        <span class="cov8" title="1">var s *section
        lineNum := 0
        scanner := bufio.NewScanner(r)
        for scanner.Scan() </span><span class="cov8" title="1">{
                lineNum++
                line := scanner.Text()
                if isSectionSeparatorLine(line) </span><span class="cov8" title="1">{ //start a new section
                        if s != nil </span><span class="cov8" title="1">{ //there is an active section, append it to the sections array
                                ri.sections = append(ri.sections, s)
                        }</span>
                        <span class="cov8" title="1">s = newSection(scriptIdentifer, lineNum+1, sectionUnknown)</span> //section if any starts on the next line
                }<span class="cov8" title="1"> else {
                        //TODO: remove this if
                        if s == nil </span><span class="cov0" title="0">{ //if text found before a SectionSeparator (at the start of a script)-&gt; a caption section
                                s = newSection(scriptIdentifer, lineNum, sectionCaption)
                        }</span>
                        <span class="cov8" title="1">s.lines = append(s.lines, line)</span>
                }
        }

        <span class="cov8" title="1">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse file %s", err)
        }</span>
        <span class="cov8" title="1">if err := ri.createTables(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error parsing tables(s): %s", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (ri *Interpreter) runTableCommands(table *table) error <span class="cov0" title="0">{
        for _, cmd := range table.cmdList </span><span class="cov0" title="0">{
                switch cmd.token </span>{
                case kwSet:</span><span class="cov0" title="0">
                        //do nothing parser would have handled that
                case kwMerge:<span class="cov0" title="0">
                        if err := table.Merge(cmd.cellRange); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("merge command %s failed %s", cmd, err)
                        }</span>
                default:<span class="cov0" title="0">
                        return fmt.Errorf("cannot run unknown command %s ", cmd)</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func (ri *Interpreter) runTables() error <span class="cov0" title="0">{
        for _, t := range ri.tables </span><span class="cov0" title="0">{
                if err := ri.runTableCommands(t); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to run commands for table %s", err)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (ri *Interpreter) renderTables(w io.Writer, r *HtmlRenderer) error <span class="cov0" title="0">{
        r.SetWriter(w)
        r.SetSettings(ri.settings)
        r.SetTables(ri.tables)
        r.StartFile()
        for _, t := range ri.tables </span><span class="cov0" title="0">{
                r.StartTable(t)
                for _, row := range t.contents.rows </span><span class="cov0" title="0">{
                        r.StartRow(row)
                        for _, cell := range row.cells </span><span class="cov0" title="0">{
                                r.OutputCell(cell)
                        }</span>
                        <span class="cov0" title="0">r.EndRow(row)</span>
                }
                <span class="cov0" title="0">r.EndTable(t)</span>
        }
        <span class="cov0" title="0">r.EndFile()
        return nil</span>
}

//ParseFile convenience function to parse a file
func ParseFile(ri *Interpreter, filename string) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse file %s", err)
        }</span>
        <span class="cov8" title="1">defer file.Close()
        return ri.Parse(file, filename)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package rosewood

import (
        "fmt"
        "io/ioutil"
        "strconv"
)

func (p *CommandParser) runSetCommand(cmd *Command) error <span class="cov0" title="0">{
        getArgAsString := func(argIndex int, reqLen int) (string, error) </span><span class="cov0" title="0">{
                s := cmd.args.Arg(argIndex)
                if len(s) &lt; reqLen </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("invalid argument in set command")
                }</span>
                <span class="cov0" title="0">return s, nil</span>
        }
        // openFile := func(fileName string) (*os.File, error) {
        //         return os.Open(fileName)
        // }
        <span class="cov0" title="0">loadTable := func(fileName string) (*tableData, error) </span><span class="cov0" title="0">{
                if data, err := ioutil.ReadFile(fileName); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to load table data %s", err)
                }</span><span class="cov0" title="0"> else {
                        return ParseTableData(string(data))
                }</span>
        }

        <span class="cov0" title="0">var s string
        var err error

        switch cmd.args[0] </span>{ //setting name
        case "rangeseparator":<span class="cov0" title="0">
                if s, err = getArgAsString(1, 1); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">p.settings.RangeOperator = rune((s)[0])</span>
        case "mandatorycol":<span class="cov0" title="0">
                if s, err = getArgAsString(1, 4); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if p.settings.MandatoryCol, err = strconv.ParseBool(s); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case "tablefilename":<span class="cov0" title="0">
                if s, err = getArgAsString(1, 1); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if table, err := loadTable(s); err != nil </span><span class="cov0" title="0">{
                        fmt.Println("an error occurred ", err)
                        return err
                }</span><span class="cov0" title="0"> else {
                        p.tables = append(p.tables, table)
                        p.settings.TableFileName = s
                        if p.settings.Debug </span><span class="cov0" title="0">{
                                fmt.Printf("%v", table)
                        }</span>
                }
        case "logfilename":<span class="cov0" title="0">
                if s, err = getArgAsString(1, 1); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">p.settings.LogFileName = s</span> //change to method on CommandParser
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown option %s", cmd.args[0])</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package rosewood

type ReportStatus int

const (
        Info ReportStatus = iota
        Echo
        Warning
        Error
        Fatal
)

//Settings implements a simple configuration solution.
type Settings struct {
        RangeOperator int32
        MandatoryCol  bool
        StyleSheet    string
        TableFileName string
        LogFileName   string
        Debug         bool
        RunMode       RunMode
        Report        func(string, ReportStatus)
}

//todo: add support for loadDefaultSettings call back
func NewSettings() *Settings <span class="cov8" title="1">{
        s := Settings{}
        return &amp;s
}</span>

//defaultSettings: returns default settings in case no settings were set.
func DefaultSettings() *Settings <span class="cov8" title="1">{
        settings := NewSettings()
        settings.RangeOperator = ':'
        settings.Debug = true
        // if ri.debug {
        //         log.Printf("default settings loaded")
        // }
        return settings
}</span>

// func (s Settings) String() string {
//         return fmt.Sprintf("Settings:\n %#v", s)
// }

// //todo: change path to io.reader
// func (s *Settings) LoadSettings(path string) error {
//         file, err := ioutil.ReadFile(path)
//         if err != nil {
//                 return fmt.Errorf("failed to load settings: %v", err)
//         }
//         err = json.Unmarshal(file, &amp;s.items)
//         if err != nil {
//                 return fmt.Errorf("failed to parse settings: %v", err)
//         }
//         return nil
// }

// //todo: change path to io.writer
// func (s *Settings) SaveSettings(path string, replace true) error {
//         file, err := os.Create(path)
//         if err != nil {
//                 return fmt.Errorf("failed to save settings: %v", err)
//         }
//         defer file.Close()
//         e := json.NewEncoder(file)
//         if err := e.Encode(s.items); err != nil {
//                 return fmt.Errorf("failed to save settings: %v", err)
//         }
//         return nil
// }
</pre>
		
		<pre class="file" id="file7" style="display: none">package rosewood

//Table holds all the info needed to render a table
type table struct {
        identifier string
        contents   *tableData
        caption    *section
        header     *section
        footnotes  *section
        cmdList    []*Command
}

func newTable() *table <span class="cov8" title="1">{
        return &amp;table{}
}</span>

func (t *table) Merge(ra Range) error <span class="cov0" title="0">{
        return t.contents.merge(ra)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package rosewood

import (
        "bytes"
        "fmt"
        "strings"
)

//add parent link in each object to its parent: cell-&gt;range or row-&gt;table
//add interface to use in parent property; flds: topleft, bottomright coords, parent

type tableData struct {
        rows        []*Row
        maxFldCount RwInt
}

func (t *tableData) String() string <span class="cov8" title="1">{
        var b bytes.Buffer
        // if t.rows == nil {
        //         return "invalid: rows is nil"
        // }
        for _, r := range t.rows </span><span class="cov8" title="1">{
                b.WriteString(r.String())
                b.WriteString(EOL)
        }</span>
        <span class="cov8" title="1">return b.String()</span>
}

func (t *tableData) ValidCoordinate(row, col RwInt) bool <span class="cov0" title="0">{
        if row &lt; 1 || row &gt; RwInt(len(t.rows)) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if col &lt; 1 || col &gt; RwInt(len(t.rows[row-1].cells)) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

func (t *tableData) Cell(row, col RwInt) *Cell <span class="cov0" title="0">{
        if !t.ValidCoordinate(row, col) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return t.cell(row, col)</span>
}

func (t *tableData) cell(row, col RwInt) *Cell <span class="cov0" title="0">{
        return t.rows[row-1].cells[col-1]
}</span>

func (t *tableData) merge(ra Range) error <span class="cov0" title="0">{
        if err := ra.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("merge command failed %s", err)
        }</span>
        <span class="cov0" title="0">for r := ra.TopLeft.Row; r &lt;= ra.BottomRight.Row; r++ </span><span class="cov0" title="0">{
                for c := ra.TopLeft.Col; c &lt;= ra.BottomRight.Col; c++ </span><span class="cov0" title="0">{
                        t.cell(r, c).hidden = true
                }</span>
        }
        <span class="cov0" title="0">topleft := t.cell(ra.TopLeft.Row, ra.TopLeft.Col)
        topleft.hidden = false
        topleft.rowSpan = ra.BottomRight.Row - ra.TopLeft.Row
        topleft.colSpan = ra.BottomRight.Col - ra.TopLeft.Col
        return nil</span>
}

type Row struct {
        cells []*Cell
}

func (r *Row) String() string <span class="cov8" title="1">{
        var b bytes.Buffer
        for _, c := range r.cells </span><span class="cov8" title="1">{
                b.WriteString(c.String())
                b.WriteString(columnSeparator)
        }</span>
        <span class="cov8" title="1">return b.String()</span>
}

type Cell struct {
        text             string
        row, col         RwInt
        hidden           bool
        rowSpan, colSpan RwInt
}

func NewCell(text string, row, col RwInt) *Cell <span class="cov8" title="1">{
        return &amp;Cell{
                text: text,
                row:  row,
                col:  col}
}</span>

// func NewHiddenCell(text string, row, col int) *Cell {
//         return &amp;Cell{
//                 text:   text,
//                 row:    row,
//                 col:    col,
//                 hidden: true}
// }

func (c *Cell) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("r%d c%d: %s", c.row, c.col, c.text)
}</span>

func ParseTableData(s string) (*tableData, error) <span class="cov8" title="1">{
        var (
                line, offset          RwInt
                fldCount, maxFldCount RwInt
                cells                 []*Cell
                rows                  []*Row
        )
        if strings.TrimSpace(s) == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("empty table")
        }</span>
        <span class="cov8" title="1">line = 1
        for pos := 0; pos &lt; len(s); pos++ </span><span class="cov8" title="1">{
                switch s[pos] </span>{
                case '\r':</span><span class="cov8" title="1"> //carriage return followed by linefeed as EOL sequence (Windows)
                        //todo: \r must be preceded by |
                case '\n':<span class="cov8" title="1"> //linefeed for Linux and MacOs as EOL marker
                        //todo: \n must be preceded by | or \r
                        line++
                        offset = RwInt(pos + 1) //offset is now just after the \n
                        if fldCount &gt; maxFldCount </span><span class="cov8" title="1">{
                                maxFldCount = fldCount
                        }</span>
                        <span class="cov8" title="1">rows = append(rows, &amp;Row{cells: cells}) //create a row with currents cells and append to rows
                        fldCount = 0                            //reset fldcount
                        cells = nil</span>                             //emtpy the cell slice
                case '|':<span class="cov8" title="1">
                        fldCount++
                        cell := NewCell(s[offset:pos], line, fldCount) //text from last offset to just before the separator
                        cells = append(cells, cell)
                        offset = RwInt(pos + 1)</span> //offset is now just after the separator
                }
        }
        <span class="cov8" title="1">if maxFldCount == 0 || len(rows) == 0 </span><span class="cov8" title="1">{ //no fields or rows found
                return nil, fmt.Errorf("invalid data table")
        }</span>
        <span class="cov8" title="1">return &amp;tableData{rows: rows,
                maxFldCount: maxFldCount}, nil</span>

}

//for testing only; it ignores errors
func monadicParseTableData(s string) *tableData <span class="cov0" title="0">{
        t, _ := ParseTableData(s)
        return t
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package rosewood

import (
        "os"
        "path/filepath"
)

//todo merge with other utils

func GetWorkingDir() string <span class="cov0" title="0">{
        dir, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return filepath.Dir(dir)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
